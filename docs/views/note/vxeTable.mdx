import img1 from '../../assets/vxetable1.png';
import img2 from '../../assets/vxetable2.png';
import img3 from '../../assets/vxetable3.png';
import img4 from '../../assets/vxetable4.png';

# 记录一次调试vxeTable源码

:::tip 提示

**`vxe-table`** 是vue3的一个表格插件.

:::

## 经过

事实是这样的, 突然有一天同事说这个表格怎么这么卡呢.试了一下也确实是, 滑动的时候莫名的卡顿  
并且才100条数据就已经能肉眼感觉卡顿了.

## 定位

### 场景复现

```jsx pure

// 模拟100列
const columns = new Array(100).fill(0).map((item, index) => {
    return {
        feild: `name${index}`,
        title: `测试${index}`,
        width: 300,
    };
});

const config = [
    {
        field: 'name0',
        title: '测试-1',
        fixed: 'left',
        width: 300,
    },
    ...columns,
]


```

### 打开chorme性能面板分析


<img src={img1} />  

:::tip 结果

可以看到一个很熟悉的函数, **`patch`** , 这个是vue源码里面的diff算法函数.  
**`diff算法`** 其实是在对比 **`虚拟DOM`** 和 **`挂载DOM`** 的一个过程.
它是一个 **`递归`** 的过程.  

耗时发生在它身上说明 `dom节点太多了`.  

但不科学的是, 才一百列, 十条数据, 并且已经开启了虚拟滚动. 理论上不应该出现卡顿.  

但事实却很奇怪...继续排查.

:::

### 控制台打印节点个数

<img src={img2} />

:::tip 结果

从输出看上是 `一千多个单元格节点`, 是不是以为是对的 100 * 10 都一千个了.但是实际上是不对的, 因为开启了虚拟滚动,   
看不见的节点很多是没经过渲染的.问题就在这了.  

接着, 鼠标移上去发现 `很多节点是重复` 的.

:::

### 验证是否重复渲染节点

```jsx pure

// 把第一列改为自定义渲染
{
    field: 'name0',
    title: '测试0',
    fixed: 'left',
    width: 300,
    slots: {
        default: () => {
            // 自定义类名, 用于定位节点渲染. 
            return h('div', { class: 'custom_dom_demo' }, 123);
        },
    },
}


```

#### 继续控制台打印节点个数.

<img src={img3} />

:::info 结果

问题得到了验证, 10条数据但是节点被渲染了20次, **`多了一倍的节点`**.

最终的结果是发现, **`当存在 fixed 固定列时, 整个表格会被多渲染 1-2 倍的节点`**

:::

## 验证是否为插件问题

:::info 方案

到官网的demo上用上面的方案定位了一下, 发现 **`并没有`** 出现相同的情况  
这种情况就有点棘手了, 因为很难定位到具体是哪行代码导致了表格插件出现了重复渲染.

:::

## 解决

> 走投无路, 最终只能是去debug源码.

:::tip 问题

官方又不存在这个问题, 应该如何在源码上复现呢?  

这时候就要使用另外的一个东西了. 那就是 **`npm link`**  

这个命令呢, 是用来调试本地库的, 相当于一个 `软连接` ,

比如: 当你在代码里面写上 `import xxModule from 'xxmodule'` 时,  
实际上是引入了 `npm install` 装的包. 但 `npm install` 是需要你发布到 `npmjs.com` 上才可以的.  
现在如果是本地开发过程中, 又想测试的话怎么办呢, 就可以使用 `npm link` , 将这个包链接到全局. 并在项目中 link 进来.  

具体的信息请自行查询, 这里不做过多解释.

:::

> 终于在一通打印调试之后, 在源码里面发现了问题.

<img src={img4} />

:::tip 结果

当配置了扩展列并且存在固定列时, 固定列会进行 **`全量渲染`**, 就是将整个表格又渲染一遍.  
如果左右都存在固定列, 那么将多渲染 **`2倍`** 的节点. 这就是卡顿的最终原因.

:::

## 修改代码

> 原来, 调用方并没有配置扩展行, 但是在二次封装时写上了, 

```jsx pure

// 留给调用方根据配置项动态显示/隐藏扩展列
{ type: 'expand', width: 50, visible: !!isExpand }

```

> 也就是这一列, 导致了表格开启了全量渲染, 因为表格内部只判断了是否存在该列, 并没有判断该列是否隐藏.
> 所以, 问题的根源找到了.

> 最后问题就解决了. 根据配置项动态判断是否把该列加到列配置上去, 而不是加上后根据配置判断显隐.

## 结束