[{"id":0,"title":"","content":"","routePath":"/doc/components/test","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"Markdown & MDX","content":"#\n\nRspress supports not only Markdown but also MDX, a powerful way to develop\ncontent.\n\n\nMarkdown#\n\nMDX is a superset of Markdown, which means you can write Markdown files as\nusual. For example:\n\n\n\n\nUse Component#\n\nWhen you want to use React components in Markdown files, you should name your\nfiles with .mdx extension. For example:\n\n\n\n\nFront Matter#\n\nYou can add Front Matter at the beginning of your Markdown file, which is a\nYAML-formatted object that defines some metadata. For example:\n\n\n\n> Note: By default, Rspress uses h1 headings as html headings.\n\nYou can also access properties defined in Front Matter in the body, for example:\n\n\n\nThe previously defined properties will be passed to the component as frontmatter\nproperties. So the final output will be:\n\n\n\n\nCustom Container#\n\nYou can use the ::: syntax to create custom containers and support custom\ntitles. For example:\n\nInput:\n\n\n\nOutput:\n\nTIP\n\nThis is a block of type tip\n\nINFO\n\nThis is a block of type info\n\nWARNING\n\nThis is a block of type warning\n\nDANGER\n\nThis is a block of type danger\n\nDETAILS\n\nThis is a block of type details\n\nCustom Title\n\nThis is a block of Custom Title\n\nCustom Title\n\nThis is a block of Custom Title\n\n\nCode Block#\n\n\nBasic Usage#\n\nYou can use the ``` syntax to create code blocks and support custom titles. For\nexample:\n\nInput:\n\n\n\nOutput:\n\n\n\n\n\n\nShow Line Numbers#\n\nIf you want to display line numbers, you can enable the showLineNumbers option\nin the config file:\n\n\n\n\nWrap Code#\n\nIf you want to wrap long code line by default, you can enable the\ndefaultWrapCode option in the config file:\n\n\n\n\nLine Highlighting#\n\nYou can also apply line highlighting and code block title at the same time, for\nexample:\n\nInput:\n\n\n\nOuput:\n\n\n\n\nRustify MDX compiler#\n\nYou can enable Rustify MDX compiler by following config:","routePath":"/doc/guide/","lang":"","toc":[{"text":"Markdown","id":"markdown","depth":2,"charIndex":88},{"text":"Use Component","id":"use-component","depth":2,"charIndex":198},{"text":"Front Matter","id":"front-matter","depth":2,"charIndex":336},{"text":"Custom Container","id":"custom-container","depth":2,"charIndex":767},{"text":"Code Block","id":"code-block","depth":2,"charIndex":1190},{"text":"Basic Usage","id":"basic-usage","depth":3,"charIndex":1204},{"text":"Show Line Numbers","id":"show-line-numbers","depth":3,"charIndex":1332},{"text":"Wrap Code","id":"wrap-code","depth":3,"charIndex":1455},{"text":"Line Highlighting","id":"line-highlighting","depth":3,"charIndex":1580},{"text":"Rustify MDX compiler","id":"rustify-mdx-compiler","depth":2,"charIndex":1711}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"联系我","content":"#\n\n欢迎\n\n如果你觉得哪里写的不对或者想进一步讨论的, 欢迎与我联系.\n\n扫描以下二维码, 注明来意","routePath":"/doc/views/contact/me","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"配置式表格单元格渲染","content":"#\n\n\n需求场景#\n\n在后台管理系统中, 绝大多数页面基本都是 增删改查, 即页面上很多都是 表格+多表单\n\n在表格中, 就存在一个场景, 即单元格的内容是多样化的, 比如:\n\n等等...\n\n\n通用方式#\n\n其实这些功能在项目中都是 高度可复用 的, 常规的做法是使用 render 函数 自定义渲染单元格内容\n\n并将功能封装成组件进行复用, 但这种做法存在的问题是:\n\n>  1. 需要重复引入. 对于调用方来说, 他需要在页面内引入该组件进行渲染\n>  2. 当存在多个功能时, 功能之间将难以组合.\n\n提示\n\n文档框架使用的是 react 进行渲染的, 所以这里举例会使用 Ant-design UI库 进行编写\n\n这里只提供一种可行的思路, 仅供参考~\n\n\n开始#\n\n> 问题明白了, 那么就开始吧, 简单封装一下table组件. 让它支持配置式的单元格渲染.\n\n解释#\n\n相信你一定使用过 配置式的多表单, 使用方式上是一样的, 即在表格列配置上多加一列表示单元格的渲染内容. 通过配置的形式即可解决上面的第一个问题, 即\n需要重复引入.\n\n但在实现上, 和多表单的可能 . 因为多表单可以直接通过循环然后拿到映射的组件直接展示出来. 但在这个场景下, 不能直接这么做,\n\n还记得上面的第二个问题吗, 当存在多个功能时, 功能之间将难以组合, 在真是业务场景中, 往往会存在多个功能项组合的情况,那么如果直接循环展示的话,\n在布局上就会被限制.\n\n因为你 无法确定 未来扩展的组件会需要什么样的布局, 有可能是左右布局, 有可能是上下布局, 也有可能发生嵌套, 在这些情况下, 注定了无法直接循环展示.\n\n编码#\n\n> 需要和基本的设计框架已经确定好了, 就可以开始了.\n\n在 antd / table 这个组件中, 需要自定义单元格内容的入口就是 render 函数 . 那么就直接在封装的表格里面手动代理 render函数\n\n基础框架#\n\n\n\n核心逻辑#\n\n\n\n扩展组件#\n\n\n\nDemo#\n\n\n\n\n看看效果#\n\n\n\n\n说明#\n\n看到最后你应该知道了该功能的原理了.\n\n实际上就是代理了 , 并在组件内部去处理和匹配组件, 并将上一个组件暴露给下一个组件去渲染. 从而实现\n\n注意\n\n上面只是一个非常简单的功能复现, 只是简单的写下了思路, 真正在项目开发中, 还有 非常多 的不同的需求.\n\n我没有把完整的代码写出来, 因为那样太过复杂, 不利于理解.\n\n真正在项目中, 你可能需要 扩展 该功能\n\n比如:\n\n0. 如何干预组件内部的逻辑. 你需要在每个组件预留参数给调用方去使用. 比如, 复制功能要给调用方预留自定义复制内容的功能...\n\n 1. 动态组合. 有些情况下, 调用方可能需要动态决定需要哪些组件, 比如有些单元格我需要复制按钮, 有些单元格我又不需要...\n 2. 缓存策略. 一个非常常见的场景是刷新, 刷新的时候单元格的内容有很大概率可能是不会发生数据更新的, 这时候你需要实现单元格内容的缓存, 而不是重新渲染.\n 3. 类型支持. 应该是需要使用ts进行类型定义, 将会方便调用方使用.\n\n...\n\n\n优劣分析#\n\n优点\n 0. 多个功能组件的解耦 + 自由组合.\n 1. 从设计上符合单一职责原则, 开闭原则.\n 2. 解决了传统解决方案下的几个问题.\n 3. 配置式的写法为未来低代码控制提供了可能性.\n\n缺点\n 0. 每次扩展组件都需要手动渲染上一个组件并 透传所有的 props\n    \n    (本质上是为了灵活, 但实际上别人在开发中总是会忘记这一步, 如果少了这一步, 整个渲染链条将中断, 从这个角度来说, 也有点强制的意思了.)\n 1. 文案的渲染是在最底层组件去做的, 为的是扩展的组件不需要在意这一步操作. 但有个情况是如果扩展的组件需要控制这个文案的点击事情或者是设置文案的样式等等,\n    那么这个操作将非常麻烦, 需要透传属性.\n\n总的来说, 缺点在于 扩展组件时 的写法有些许限制, 或者说需要注意.\n\n总结\n\n总的来说, 是 利大于弊 的做法. 因为对于调用方来说, 将是非常方便的存在","routePath":"/doc/views/encapsulation/tableCellRender","lang":"","toc":[{"text":"需求场景","id":"需求场景","depth":3,"charIndex":3},{"text":"通用方式","id":"通用方式","depth":3,"charIndex":96},{"text":"开始","id":"开始","depth":3,"charIndex":332},{"text":"解释","id":"解释","depth":4,"charIndex":385},{"text":"编码","id":"编码","depth":4,"charIndex":707},{"text":"看看效果","id":"看看效果","depth":3,"charIndex":856},{"text":"说明","id":"说明","depth":3,"charIndex":866},{"text":"优劣分析","id":"优劣分析","depth":3,"charIndex":1321}],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"浏览器并发限制的原因","content":"#\n\n\n1.对操作系统端口资源考虑#\n\nPC总端口数为65536，那么一个TCP（http也是tcp）链接就占用一个端口。操作系统通常会对总端口一半开放对外请求，以防端口数量不被迅速消耗殆尽。\n\n\n2.避免同一客服端并发大量请求超过服务端的并发阈值#\n\n在服务端通常都对同一个客户端来源设置并发阀值避免恶意攻击，如果浏览器不对同一域名做并发限制可能会导致超过服务端的并发阀值被拦截掉.\n\n参考链接\n\nhttps://segmentfault.com/a/1190000039157302","routePath":"/doc/views/expand/browserConcurrency","lang":"","toc":[{"text":"1.对操作系统端口资源考虑","id":"1对操作系统端口资源考虑","depth":3,"charIndex":3},{"text":"2.避免同一客服端并发大量请求超过服务端的并发阈值","id":"2避免同一客服端并发大量请求超过服务端的并发阈值","depth":3,"charIndex":98}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"测试一下..","content":"#","routePath":"/doc/views/experience/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"任务并发控制","content":"#\n\n> 如果你是一个前端开发, 你应该知道浏览器对同域名的请求是有并发限制的.\n> \n> 比如chrome中, 这个限制为 6个 , 也就是说, 如果你初始化的资源请求超过 6个 时, 多余的将进行等待,\n> \n> 等到有空缺时才进行请求, 也就是同一时间 最多只能是6个 .\n\n提示\n\n具体原因可以点击:\n\n\n自己实现任务池限制#\n\n> 在前端代码上, 我们要实现的就不仅仅是请求层面的控制, 而是针对所有情况, 应该是说 Task(任务) , 任何一个函数都可以称为一个任务.","routePath":"/doc/views/note/requestControl","lang":"","toc":[{"text":"自己实现任务池限制","id":"自己实现任务池限制","depth":2,"charIndex":156}],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"记录一次调试vxeTable源码","content":"#\n\n提示\n\nvxe-table 是vue3的一个表格插件.\n\n\n经过#\n\n事实是这样的, 突然有一天同事说这个表格怎么这么卡呢.试了一下也确实是, 滑动的时候莫名的卡顿\n\n并且才100条数据就已经能肉眼感觉卡顿了.\n\n\n定位#\n\n\n场景复现#\n\n\n\n\n打开chorme性能面板分析#\n\n结果\n\n可以看到一个很熟悉的函数, patch , 这个是vue源码里面的diff算法函数.\n\ndiff算法 其实是在对比 虚拟DOM 和 挂载DOM 的一个过程. 它是一个 递归 的过程.\n\n耗时发生在它身上说明 dom节点太多了.\n\n但不科学的是, 才一百列, 十条数据, 并且已经开启了虚拟滚动. 理论上不应该出现卡顿.\n\n但事实却很奇怪...继续排查.\n\n\n控制台打印节点个数#\n\n结果\n\n从输出看上是 一千多个单元格节点, 是不是以为是对的 100 * 10 都一千个了.但是实际上是不对的, 因为开启了虚拟滚动,\n\n看不见的节点很多是没经过渲染的.问题就在这了.\n\n接着, 鼠标移上去发现 很多节点是重复 的.\n\n\n验证是否重复渲染节点#\n\n\n\n继续控制台打印节点个数.#\n\n结果\n\n问题得到了验证, 10条数据但是节点被渲染了20次, 多了一倍的节点.\n\n最终的结果是发现, 当存在 fixed 固定列时, 整个表格会被多渲染 1-2 倍的节点\n\n\n验证是否为插件问题#\n\n方案\n\n到官网的demo上用上面的方案定位了一下, 发现 并没有 出现相同的情况\n\n这种情况就有点棘手了, 因为很难定位到具体是哪行代码导致了表格插件出现了重复渲染.\n\n\n解决#\n\n> 走投无路, 最终只能是去debug源码.\n\n问题\n\n官方又不存在这个问题, 应该如何在源码上复现呢?\n\n这时候就要使用另外的一个东西了. 那就是 npm link\n\n这个命令呢, 是用来调试本地库的, 相当于一个 软连接 ,\n\n比如: 当你在代码里面写上 `` 时,\n\n实际上是引入了 npm install 装的包. 但 npm install 是需要你发布到 npmjs.com 上才可以的.\n\n现在如果是本地开发过程中, 又想测试的话怎么办呢, 就可以使用 npm link , 将这个包链接到全局. 并在项目中 link 进来.\n\n具体的信息请自行查询, 这里不做过多解释.\n\n> 终于在一通打印调试之后, 在源码里面发现了问题.\n\n结果\n\n当配置了扩展列并且存在固定列时, 固定列会进行 全量渲染, 就是将整个表格又渲染一遍.\n\n如果左右都存在固定列, 那么将多渲染 2倍 的节点. 这就是卡顿的最终原因.\n\n\n修改代码#\n\n> 原来, 调用方并没有配置扩展行, 但是在二次封装时写上了,\n\n\n\n> 也就是这一列, 导致了表格开启了全量渲染, 因为表格内部只判断了是否存在该列, 并没有判断该列是否隐藏. 所以, 问题的根源找到了.\n\n> 最后问题就解决了. 根据配置项动态判断是否把该列加到列配置上去, 而不是加上后根据配置判断显隐.\n\n\n结束#","routePath":"/doc/views/note/vxeTable","lang":"","toc":[{"text":"经过","id":"经过","depth":2,"charIndex":32},{"text":"定位","id":"定位","depth":2,"charIndex":110},{"text":"场景复现","id":"场景复现","depth":3,"charIndex":116},{"text":"打开chorme性能面板分析","id":"打开chorme性能面板分析","depth":3,"charIndex":126},{"text":"控制台打印节点个数","id":"控制台打印节点个数","depth":3,"charIndex":326},{"text":"验证是否重复渲染节点","id":"验证是否重复渲染节点","depth":3,"charIndex":457},{"text":"继续控制台打印节点个数.","id":"继续控制台打印节点个数","depth":4,"charIndex":472},{"text":"验证是否为插件问题","id":"验证是否为插件问题","depth":2,"charIndex":575},{"text":"解决","id":"解决","depth":2,"charIndex":673},{"text":"修改代码","id":"修改代码","depth":2,"charIndex":1091},{"text":"结束","id":"结束","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"测试一下..","content":"#","routePath":"/doc/views/reflection/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"测试一下..","content":"#","routePath":"/doc/views/study/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"如何等待分散在不同的模块内部的多个异步结束?","content":"#\n\n\n场景#\n\n> 在表格中, 表格的数据取决于其他的几个状态, 并且这几个状态都是异步获取的 这几个状态都分散在不同的几个模块内部,\n> 那么该如何组织代码才可以比较友好的实现该需求.\n\n\n示例#\n\n> 上面是一个最简单的示例复现.\n> \n> 想象一下, 顶部的三个状态都是异步请求回来的, 并且有可能这三个是分布在 不同 的组件内部,\n> \n> 表格需要等到这三个 异步结束 后再去请求数据.\n\n思考\n\n针对以上的场景, 应该如何组织代码才可以比较友好呢?\n\n\n目前的解决方案#\n\n问题\n\n这个方案看似解决了问题, 即多个模块可以单独调用加载方法, 不需要管其他状态是否结束. 最终的请求由表格内部去判断什么时候执行.\n\n但是, 这引发了其他的问题.\n\n 0. 调用方需要手动指定初始化时总共有多少个异步状态, 也就说初始化时需要调用多少次加载方法, 因为表格并不能感知这个条件, 所以无法判断啥时候需要发起请求.\n 1. 如果存在多个状态, 但其中一个状态失败了, 这种情况将有点麻烦. 可能还需要手动指定是否需要发起请求.","routePath":"/doc/views/think/asyncAwait","lang":"","toc":[{"text":"场景","id":"场景","depth":2,"charIndex":3},{"text":"示例","id":"示例","depth":2,"charIndex":96},{"text":"目前的解决方案","id":"目前的解决方案","depth":2,"charIndex":233}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"思考: 多个hook之间的耦合度应该如何解耦","content":"#\n\n> 现在 函数式编程 是前端开发中的主流思想, hook 也作为主流的思想被越来越多人所实践并推行.\n> \n> 但在实践开发中, 总会遇到一种情况, 就是 多个hook 之间的相互依赖.\n\n\n\n按上面的例子, useHookB 依赖了 useHookA 的一个状态.这还是一个最简单的一种情况, 实际情况中可能更加复杂.\n\n可能存在多个 hook 相互依赖等情况.\n\n思考\n\n应该如何去解耦这中间的耦合?\n\n有兴趣可以看看下面这个解决方案: vue3 + IOC\n\nhttps://zova.js.org/zh/guide/start/why.html","routePath":"/doc/views/think/hook","lang":"","toc":[],"domain":"","frontmatter":{},"version":""}]