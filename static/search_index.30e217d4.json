[{"id":0,"title":"","content":"","routePath":"/doc/components/test","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"Markdown & MDX","content":"#\n\nRspress supports not only Markdown but also MDX, a powerful way to develop\ncontent.\n\n\nMarkdown#\n\nMDX is a superset of Markdown, which means you can write Markdown files as\nusual. For example:\n\n\n\n\nUse Component#\n\nWhen you want to use React components in Markdown files, you should name your\nfiles with .mdx extension. For example:\n\n\n\n\nFront Matter#\n\nYou can add Front Matter at the beginning of your Markdown file, which is a\nYAML-formatted object that defines some metadata. For example:\n\n\n\n> Note: By default, Rspress uses h1 headings as html headings.\n\nYou can also access properties defined in Front Matter in the body, for example:\n\n\n\nThe previously defined properties will be passed to the component as frontmatter\nproperties. So the final output will be:\n\n\n\n\nCustom Container#\n\nYou can use the ::: syntax to create custom containers and support custom\ntitles. For example:\n\nInput:\n\n\n\nOutput:\n\nTIP\n\nThis is a block of type tip\n\nINFO\n\nThis is a block of type info\n\nWARNING\n\nThis is a block of type warning\n\nDANGER\n\nThis is a block of type danger\n\nDETAILS\n\nThis is a block of type details\n\nCustom Title\n\nThis is a block of Custom Title\n\nCustom Title\n\nThis is a block of Custom Title\n\n\nCode Block#\n\n\nBasic Usage#\n\nYou can use the ``` syntax to create code blocks and support custom titles. For\nexample:\n\nInput:\n\n\n\nOutput:\n\n\n\n\n\n\nShow Line Numbers#\n\nIf you want to display line numbers, you can enable the showLineNumbers option\nin the config file:\n\n\n\n\nWrap Code#\n\nIf you want to wrap long code line by default, you can enable the\ndefaultWrapCode option in the config file:\n\n\n\n\nLine Highlighting#\n\nYou can also apply line highlighting and code block title at the same time, for\nexample:\n\nInput:\n\n\n\nOuput:\n\n\n\n\nRustify MDX compiler#\n\nYou can enable Rustify MDX compiler by following config:","routePath":"/doc/guide/","lang":"","toc":[{"text":"Markdown","id":"markdown","depth":2,"charIndex":88},{"text":"Use Component","id":"use-component","depth":2,"charIndex":198},{"text":"Front Matter","id":"front-matter","depth":2,"charIndex":336},{"text":"Custom Container","id":"custom-container","depth":2,"charIndex":767},{"text":"Code Block","id":"code-block","depth":2,"charIndex":1190},{"text":"Basic Usage","id":"basic-usage","depth":3,"charIndex":1204},{"text":"Show Line Numbers","id":"show-line-numbers","depth":3,"charIndex":1332},{"text":"Wrap Code","id":"wrap-code","depth":3,"charIndex":1455},{"text":"Line Highlighting","id":"line-highlighting","depth":3,"charIndex":1580},{"text":"Rustify MDX compiler","id":"rustify-mdx-compiler","depth":2,"charIndex":1711}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"配置式表格单元格渲染","content":"#\n\n\n需求场景#\n\n在后台管理系统中, 绝大多数页面基本都是 增删改查, 即页面上很多都是 表格+多表单\n\n在表格中, 就存在一个场景, 即单元格的内容是多样化的, 比如:\n\n等等...\n\n\n通用方式#\n\n其实这些功能在项目中都是 高度可复用 的, 常规的做法是使用 render 函数 自定义渲染单元格内容\n\n并将功能封装成组件进行复用, 但这种做法存在的问题是:\n\n>  1. 需要重复引入. 对于调用方来说, 他需要在页面内引入该组件进行渲染\n>  2. 当存在多个功能时, 功能之间将难以组合.\n\n提示\n\n文档框架使用的是 react 进行渲染的, 所以这里举例会使用 Ant-design UI库 进行编写\n\n这里只提供一种可行的思路, 仅供参考~\n\n\n开始#\n\n> 问题明白了, 那么就开始吧, 简单封装一下table组件. 让它支持配置式的单元格渲染.\n\n解释#\n\n相信你一定使用过 配置式的多表单, 使用方式上是一样的, 即在表格列配置上多加一列表示单元格的渲染内容. 通过配置的形式即可解决上面的第一个问题, 即\n需要重复引入.\n\n但在实现上, 和多表单的可能 . 因为多表单可以直接通过循环然后拿到映射的组件直接展示出来. 但在这个场景下, 不能直接这么做,\n\n还记得上面的第二个问题吗, 当存在多个功能时, 功能之间将难以组合, 在真是业务场景中, 往往会存在多个功能项组合的情况,那么如果直接循环展示的话,\n在布局上就会被限制.\n\n因为你 无法确定 未来扩展的组件会需要什么样的布局, 有可能是左右布局, 有可能是上下布局, 也有可能发生嵌套, 在这些情况下, 注定了无法直接循环展示.\n\n编码#\n\n> 需要和基本的设计框架已经确定好了, 就可以开始了.\n\n在 antd / table 这个组件中, 需要自定义单元格内容的入口就是 render 函数 . 那么就直接在封装的表格里面手动代理 render函数\n\n基础框架#\n\n\n\n核心逻辑#\n\n\n\n扩展组件#\n\n\n\nDemo#\n\n\n\n\n看看效果#\n\n\n\n\n说明#\n\n看到最后你应该知道了该功能的原理了.\n\n实际上就是代理了 , 并在组件内部去处理和匹配组件, 并将上一个组件暴露给下一个组件去渲染. 从而实现\n\n注意\n\n上面只是一个非常简单的功能复现, 只是简单的写下了思路, 真正在项目开发中, 还有 非常多 的不同的需求.\n\n我没有把完整的代码写出来, 因为那样太过复杂, 不利于理解.\n\n真正在项目中, 你可能需要 扩展 该功能\n\n比如:\n\n0. 如何干预组件内部的逻辑. 你需要在每个组件预留参数给调用方去使用. 比如, 复制功能要给调用方预留自定义复制内容的功能...\n\n 1. 动态组合. 有些情况下, 调用方可能需要动态决定需要哪些组件, 比如有些单元格我需要复制按钮, 有些单元格我又不需要...\n 2. 缓存策略. 一个非常常见的场景是刷新, 刷新的时候单元格的内容有很大概率可能是不会发生数据更新的, 这时候你需要实现单元格内容的缓存, 而不是重新渲染.\n 3. 类型支持. 应该是需要使用ts进行类型定义, 将会方便调用方使用.\n\n...\n\n\n优劣分析#\n\n优点\n 0. 多个功能组件的解耦 + 自由组合.\n 1. 从设计上符合单一职责原则, 开闭原则.\n 2. 解决了传统解决方案下的几个问题.\n 3. 配置式的写法为未来低代码控制提供了可能性.\n\n缺点\n 0. 每次扩展组件都需要手动渲染上一个组件并 透传所有的 props\n    \n    (本质上是为了灵活, 但实际上别人在开发中总是会忘记这一步, 如果少了这一步, 整个渲染链条将中断, 从这个角度来说, 也有点强制的意思了.)\n 1. 文案的渲染是在最底层组件去做的, 为的是扩展的组件不需要在意这一步操作. 但有个情况是如果扩展的组件需要控制这个文案的点击事情或者是设置文案的样式等等,\n    那么这个操作将非常麻烦, 需要透传属性.\n\n总的来说, 缺点在于 扩展组件时 的写法有些许限制, 或者说需要注意.\n\n总结\n\n总的来说, 是 利大于弊 的做法. 因为对于调用方来说, 将是非常方便的存在","routePath":"/doc/views/encapsulation/tableCellRender","lang":"","toc":[{"text":"需求场景","id":"需求场景","depth":3,"charIndex":3},{"text":"通用方式","id":"通用方式","depth":3,"charIndex":96},{"text":"开始","id":"开始","depth":3,"charIndex":332},{"text":"解释","id":"解释","depth":4,"charIndex":385},{"text":"编码","id":"编码","depth":4,"charIndex":707},{"text":"看看效果","id":"看看效果","depth":3,"charIndex":856},{"text":"说明","id":"说明","depth":3,"charIndex":866},{"text":"优劣分析","id":"优劣分析","depth":3,"charIndex":1321}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"测试一下..","content":"#","routePath":"/doc/views/experience/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"测试一下..","content":"#","routePath":"/doc/views/note/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"测试一下..","content":"#","routePath":"/doc/views/reflection/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"测试一下..","content":"#","routePath":"/doc/views/study/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"思考: 多个hook之间的耦合度应该如何解耦","content":"#\n\n> 现在 函数式编程 是前端开发中的主流思想, hook 也作为主流的思想被越来越多人所实践并推行.\n> \n> 但在实践开发中, 总会遇到一种情况, 就是 多个hook 之间的相互依赖.\n\n\n\n按上面的例子, useHookB 依赖了 useHookA 的一个状态.这还是一个最简单的一种情况, 实际情况中可能更加复杂.\n\n可能存在多个 hook 相互依赖等情况.\n\n思考\n\n应该如何去解耦这中间的耦合?\n\n有兴趣可以看看下面这个解决方案: vue3 + IOC\n\nhttps://zova.js.org/zh/guide/start/why.html","routePath":"/doc/views/think/hook","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"测试一下..","content":"#","routePath":"/doc/views/think/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""}]