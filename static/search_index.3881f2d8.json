[{"id":0,"title":"","content":"","routePath":"/doc/components/test","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"Markdown & MDX","content":"#\n\nRspress supports not only Markdown but also MDX, a powerful way to develop\ncontent.\n\n\nMarkdown#\n\nMDX is a superset of Markdown, which means you can write Markdown files as\nusual. For example:\n\n\n\n\nUse Component#\n\nWhen you want to use React components in Markdown files, you should name your\nfiles with .mdx extension. For example:\n\n\n\n\nFront Matter#\n\nYou can add Front Matter at the beginning of your Markdown file, which is a\nYAML-formatted object that defines some metadata. For example:\n\n\n\n> Note: By default, Rspress uses h1 headings as html headings.\n\nYou can also access properties defined in Front Matter in the body, for example:\n\n\n\nThe previously defined properties will be passed to the component as frontmatter\nproperties. So the final output will be:\n\n\n\n\nCustom Container#\n\nYou can use the ::: syntax to create custom containers and support custom\ntitles. For example:\n\nInput:\n\n\n\nOutput:\n\nTIP\n\nThis is a block of type tip\n\nINFO\n\nThis is a block of type info\n\nWARNING\n\nThis is a block of type warning\n\nDANGER\n\nThis is a block of type danger\n\nDETAILS\n\nThis is a block of type details\n\nCustom Title\n\nThis is a block of Custom Title\n\nCustom Title\n\nThis is a block of Custom Title\n\n\nCode Block#\n\n\nBasic Usage#\n\nYou can use the ``` syntax to create code blocks and support custom titles. For\nexample:\n\nInput:\n\n\n\nOutput:\n\n\n\n\n\n\nShow Line Numbers#\n\nIf you want to display line numbers, you can enable the showLineNumbers option\nin the config file:\n\n\n\n\nWrap Code#\n\nIf you want to wrap long code line by default, you can enable the\ndefaultWrapCode option in the config file:\n\n\n\n\nLine Highlighting#\n\nYou can also apply line highlighting and code block title at the same time, for\nexample:\n\nInput:\n\n\n\nOuput:\n\n\n\n\nRustify MDX compiler#\n\nYou can enable Rustify MDX compiler by following config:","routePath":"/doc/guide/","lang":"","toc":[{"text":"Markdown","id":"markdown","depth":2,"charIndex":88},{"text":"Use Component","id":"use-component","depth":2,"charIndex":198},{"text":"Front Matter","id":"front-matter","depth":2,"charIndex":336},{"text":"Custom Container","id":"custom-container","depth":2,"charIndex":767},{"text":"Code Block","id":"code-block","depth":2,"charIndex":1190},{"text":"Basic Usage","id":"basic-usage","depth":3,"charIndex":1204},{"text":"Show Line Numbers","id":"show-line-numbers","depth":3,"charIndex":1332},{"text":"Wrap Code","id":"wrap-code","depth":3,"charIndex":1455},{"text":"Line Highlighting","id":"line-highlighting","depth":3,"charIndex":1580},{"text":"Rustify MDX compiler","id":"rustify-mdx-compiler","depth":2,"charIndex":1711}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"联系我","content":"#\n\n欢迎\n\n如果你觉得哪里写的不对或者想进一步讨论的, 欢迎与我联系.\n\n扫描以下二维码, 注明来意","routePath":"/doc/views/contact/me","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"命令式的打开弹窗/抽屉","content":"#\n\n> 在web开发中, 一个很常见的场景就是使用 弹窗/抽屉.\n> \n> 现在常用的ui组件库的使用方法一般是通过 去控制组件的打开/关闭.\n> \n> 再通过一个事件去实现点击 的逻辑.\n> \n> 但这里就存在一个问题, 即\n\n\n一个简单的案例#\n\n\n\n提示\n\n请看上面的代码, 可以发现实际上 打开 和 确定, 这两个行为是分离的.\n\n\n实际问题#\n\n> 一个非常常见的问题是在表格中做编辑.\n> \n> 以一个简单的例子(可能这个例子不太恰当, 但能说明问题)\n\n\n\n\n问题分析#\n\n请聚焦于点击 这个动作上.\n\n这个动作需要做的事情\n\n 1. 设置弹窗的状态, 将弹窗打开.\n 2. 将数据保存并传递到弹窗内部.\n 3. 监听弹窗的 , 执行相关操作.\n\n上面的操作其实没啥问题, 但实际上存在着 的问题, 即同一个动作/行为的逻辑被分散到各个函数内部了, 无法内聚.\n\n\n方案#\n\n提示\n\n这里只给出一个大概的思路, 没有给出完整的封装代码, 因为每个项目的需求是不一样的, 只做为思路参考.\n\n我的解决方法是使用 来解决逻辑分散的问题.\n\n直接上代码.\n\n\n\n\n使用#\n\n\n\n\n\n\n说明#\n\n>  1. 上面的代码只是一个非常非常简略的代码, 思路也非常简单, 使用promise将两个分离的行为统一到一起.\n>  2. 实际开发过程中还有非常多需要考虑的地方. 比如说\n> \n> >  1. 传递传递, 弹窗内部应该是暴露一个自由度非常高的配置项出来, 由调用方手动控制, 例如弹窗标题,宽度,底部渲染,弹窗数据等等... 这些应该通过\n> >     方法传入(可以看到方法定义那里其实预留了一个config参数)\n> >  2. 嵌套弹窗, 在开发过程中, 难免会生成多个弹窗相互嵌套的情况. 这种可以通过 的形式去解决, 每次打开时都将 promise 的\n> >     resolve/reject 方法入栈, 操作完之后出栈, 这样能保证当前顺序不会错乱.\n> >  3. 阻止关闭, 在开发过程中, 很多场景下点击确定后需要 , 请求会存在失败的情况, 有时候想在 失败时阻止弹窗关闭. 这时候应该怎么办?\n> >  4. 多行为, 有时候, 其实弹窗的底部是自定义渲染的, 底部会存在非常多的情况, 单纯一个 .then 不足以区分多个按钮行为. (可以在\n> >     resolve 时暴露不同的字段去区分)\n\n\n其他#\n\n针对上面提到的问题, 站在调用方的角度, 应该是越简单越好, 所以一个可行的方案应该是在 .then 方法 中按照逻辑 return false 或者\nreturn Promise.reject() 这类的形式去阻止弹窗关闭, 类似于\n\n\n\n但是如果想实现这种效果的话, 代码需要进行改造了.\n\n\n\n在上面的代码中, model.tsx 的 openModal 并不能 获取到调用方在 .then 方法中 return 的东西\n\n一个可行的方式是 不直接返回 promise, 而是返回一个类Promise对象, 即包含then/catch/finally 方法的对象\n\n","routePath":"/doc/views/encapsulation/opendialog","lang":"","toc":[{"text":"一个简单的案例","id":"一个简单的案例","depth":2,"charIndex":116},{"text":"实际问题","id":"实际问题","depth":2,"charIndex":171},{"text":"问题分析","id":"问题分析","depth":3,"charIndex":237},{"text":"方案","id":"方案","depth":2,"charIndex":390},{"text":"使用","id":"使用","depth":3,"charIndex":486},{"text":"说明","id":"说明","depth":3,"charIndex":496},{"text":"其他","id":"其他","depth":3,"charIndex":1024}],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"配置式表格单元格渲染","content":"#\n\n\n需求场景#\n\n在后台管理系统中, 绝大多数页面基本都是 增删改查, 即页面上很多都是 表格+多表单\n\n在表格中, 就存在一个场景, 即单元格的内容是多样化的, 比如:\n\n等等...\n\n\n通用方式#\n\n其实这些功能在项目中都是 高度可复用 的, 常规的做法是使用 render 函数 自定义渲染单元格内容\n\n并将功能封装成组件进行复用, 但这种做法存在的问题是:\n\n>  1. 需要重复引入. 对于调用方来说, 他需要在页面内引入该组件进行渲染\n>  2. 当存在多个功能时, 功能之间将难以组合.\n\n提示\n\n文档框架使用的是 react 进行渲染的, 所以这里举例会使用 Ant-design UI库 进行编写\n\n这里只提供一种可行的思路, 仅供参考~\n\n\n开始#\n\n> 问题明白了, 那么就开始吧, 简单封装一下table组件. 让它支持配置式的单元格渲染.\n\n解释#\n\n相信你一定使用过 配置式的多表单, 使用方式上是一样的, 即在表格列配置上多加一列表示单元格的渲染内容. 通过配置的形式即可解决上面的第一个问题, 即\n需要重复引入.\n\n但在实现上, 和多表单的可能 . 因为多表单可以直接通过循环然后拿到映射的组件直接展示出来. 但在这个场景下, 不能直接这么做,\n\n还记得上面的第二个问题吗, 当存在多个功能时, 功能之间将难以组合, 在真是业务场景中, 往往会存在多个功能项组合的情况,那么如果直接循环展示的话,\n在布局上就会被限制.\n\n因为你 无法确定 未来扩展的组件会需要什么样的布局, 有可能是左右布局, 有可能是上下布局, 也有可能发生嵌套, 在这些情况下, 注定了无法直接循环展示.\n\n编码#\n\n> 需要和基本的设计框架已经确定好了, 就可以开始了.\n\n在 antd / table 这个组件中, 需要自定义单元格内容的入口就是 render 函数 . 那么就直接在封装的表格里面手动代理 render函数\n\n基础框架#\n\n\n\n核心逻辑#\n\n\n\n扩展组件#\n\n\n\nDemo#\n\n\n\n\n看看效果#\n\n\n\n\n说明#\n\n看到最后你应该知道了该功能的原理了.\n\n实际上就是代理了 , 并在组件内部去处理和匹配组件, 并将上一个组件暴露给下一个组件去渲染. 从而实现\n\n注意\n\n上面只是一个非常简单的功能复现, 只是简单的写下了思路, 真正在项目开发中, 还有 非常多 的不同的需求.\n\n我没有把完整的代码写出来, 因为那样太过复杂, 不利于理解.\n\n真正在项目中, 你可能需要 扩展 该功能\n\n比如:\n\n0. 如何干预组件内部的逻辑. 你需要在每个组件预留参数给调用方去使用. 比如, 复制功能要给调用方预留自定义复制内容的功能...\n\n 1. 动态组合. 有些情况下, 调用方可能需要动态决定需要哪些组件, 比如有些单元格我需要复制按钮, 有些单元格我又不需要...\n 2. 缓存策略. 一个非常常见的场景是刷新, 刷新的时候单元格的内容有很大概率可能是不会发生数据更新的, 这时候你需要实现单元格内容的缓存, 而不是重新渲染.\n 3. 类型支持. 应该是需要使用ts进行类型定义, 将会方便调用方使用.\n\n...\n\n\n优劣分析#\n\n优点\n 0. 多个功能组件的解耦 + 自由组合.\n 1. 从设计上符合单一职责原则, 开闭原则.\n 2. 解决了传统解决方案下的几个问题.\n 3. 配置式的写法为未来低代码控制提供了可能性.\n\n缺点\n 0. 每次扩展组件都需要手动渲染上一个组件并 透传所有的 props\n    \n    (本质上是为了灵活, 但实际上别人在开发中总是会忘记这一步, 如果少了这一步, 整个渲染链条将中断, 从这个角度来说, 也有点强制的意思了.)\n 1. 文案的渲染是在最底层组件去做的, 为的是扩展的组件不需要在意这一步操作. 但有个情况是如果扩展的组件需要控制这个文案的点击事情或者是设置文案的样式等等,\n    那么这个操作将非常麻烦, 需要透传属性.\n\n总的来说, 缺点在于 扩展组件时 的写法有些许限制, 或者说需要注意.\n\n总结\n\n总的来说, 是 利大于弊 的做法. 因为对于调用方来说, 将是非常方便的存在","routePath":"/doc/views/encapsulation/tableCellRender","lang":"","toc":[{"text":"需求场景","id":"需求场景","depth":3,"charIndex":3},{"text":"通用方式","id":"通用方式","depth":3,"charIndex":96},{"text":"开始","id":"开始","depth":3,"charIndex":332},{"text":"解释","id":"解释","depth":4,"charIndex":385},{"text":"编码","id":"编码","depth":4,"charIndex":707},{"text":"看看效果","id":"看看效果","depth":3,"charIndex":856},{"text":"说明","id":"说明","depth":3,"charIndex":866},{"text":"优劣分析","id":"优劣分析","depth":3,"charIndex":1321}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"浏览器并发限制的原因","content":"#\n\n\n1.对操作系统端口资源考虑#\n\nPC总端口数为65536，那么一个TCP（http也是tcp）链接就占用一个端口。操作系统通常会对总端口一半开放对外请求，以防端口数量不被迅速消耗殆尽。\n\n\n2.避免同一客服端并发大量请求超过服务端的并发阈值#\n\n在服务端通常都对同一个客户端来源设置并发阀值避免恶意攻击，如果浏览器不对同一域名做并发限制可能会导致超过服务端的并发阀值被拦截掉.\n\n参考链接\n\nhttps://segmentfault.com/a/1190000039157302","routePath":"/doc/views/expand/browserConcurrency","lang":"","toc":[{"text":"1.对操作系统端口资源考虑","id":"1对操作系统端口资源考虑","depth":3,"charIndex":3},{"text":"2.避免同一客服端并发大量请求超过服务端的并发阈值","id":"2避免同一客服端并发大量请求超过服务端的并发阈值","depth":3,"charIndex":98}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"测试一下..","content":"#","routePath":"/doc/views/experience/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"大文件传输","content":"#\n\n\n分片上传#\n\n\n背景#\n\n前后端交互过程中, 有很多文件上传的场景, 这时候如果文件过大, 就会产生一个问题, 传输时间太多, 甚至可能出现 接口超时 的情况.\n\n\n实现流程#\n\n客户端#\n\n服务端#\n\n提示\n\n以上两张流程图片来自 掘金社区 , 感谢!\n\n\n代码实现#\n\n客户端#\n\n提示\n\n选择文件 / 发送请求的封装这些步骤我就省略了, 不会全部写出来. 只写关键的分片过程 .\n\n后面会放出测试代码地址, 可自行参考.\n\n客户端这边的代码相对简单.\n\n\n\n服务端#\n\n提示\n\n这里与上面的流程图可能有些许不一样, 但大致上都差不多.\n\n下面的代码使用 express 框架编写.\n\n这里先写下几个辅助函数#\n\n\n\n接收分片接口#\n\n\n\n合并分片接口#\n\n\n\n效果展示#\n\n对于同一份文件(60MB)的上传效果, 如下图所示\n\n\n代码地址#\n\n> https://github.com/mmxCoder/demo/tree/main/splitFile\n\n\n分片下载#\n\n\n背景#\n\n与上面的分片上传是类似的, 主要解决大文件传输时的时间问题\n\n\n实现流程#\n\n客户端#\n\n服务端#\n\n\n代码实现#\n\n客户端#\n\n\n\n服务端#\n\n\n\n\n\nMDN http状态 206\n\nHTTP 206 Partial Content 成功状态响应代码表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的 Range 首部指定的。\n\n请参考: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206\n\n效果展示#\n\n提示\n\n这里的测试结果是以一份 100M 的txt文本为下载内容, 并且选择了慢一点的网络: chrome -> network -> Fast 4G\n\n因为本地太快了, 效果可能不是很明显\n\n\n代码地址#\n\n> https://github.com/mmxCoder/demo/tree/main/splitFileDownload","routePath":"/doc/views/note/bigFileTransfer","lang":"","toc":[{"text":"分片上传","id":"分片上传","depth":2,"charIndex":3},{"text":"背景","id":"背景","depth":3,"charIndex":11},{"text":"实现流程","id":"实现流程","depth":3,"charIndex":86},{"text":"客户端","id":"客户端","depth":4,"charIndex":93},{"text":"服务端","id":"服务端","depth":4,"charIndex":99},{"text":"代码实现","id":"代码实现","depth":3,"charIndex":133},{"text":"客户端","id":"客户端-1","depth":4,"charIndex":140},{"text":"服务端","id":"服务端-1","depth":4,"charIndex":235},{"text":"效果展示","id":"效果展示","depth":4,"charIndex":336},{"text":"代码地址","id":"代码地址","depth":3,"charIndex":371},{"text":"分片下载","id":"分片下载","depth":2,"charIndex":435},{"text":"背景","id":"背景-1","depth":3,"charIndex":443},{"text":"实现流程","id":"实现流程-1","depth":3,"charIndex":480},{"text":"客户端","id":"客户端-2","depth":4,"charIndex":487},{"text":"服务端","id":"服务端-2","depth":4,"charIndex":493},{"text":"代码实现","id":"代码实现-1","depth":3,"charIndex":500},{"text":"客户端","id":"客户端-3","depth":4,"charIndex":507},{"text":"服务端","id":"服务端-3","depth":4,"charIndex":515},{"text":"效果展示","id":"效果展示-1","depth":4,"charIndex":689},{"text":"代码地址","id":"代码地址-1","depth":3,"charIndex":794}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"前端数据收集","content":"#\n\nTIP\n\n这里不做过多的代码展示, 因为代码实现上并无难度, 只做一些关键性内容记录\n\n内容仅是我在项目中做到的东西, 可能并不完善\n\n里面的一些代码是从项目中提取出来的, 会尽量改成通用代码, 如有疏忽, 可以联系我修改.\n\n\n请求#\n\n在设计功能时 请求应作为 去设计, 因为它比项目内的请求器可能需要多考虑一些东西.\n\n比如:\n\n 1. 请求应该 无感 , 即要忽略掉所有的报错信息, 有些项目会在拦截器内部做统一的 错误通知 , 但这个不行, 因为要对用户无感.\n 2. 合并请求, 因为业务层的可能会频繁去触发请求, 所以需要实现数据合并发送\n 3. 最长时间发送, 当一个数据存在多长时间时就发送.\n 4. 失败重试, 接口可能因网络/服务器不稳定等原因存在失败的可能, 所有需要实现失败时重试发送.\n 5. 关闭时发送, 在页面关闭或者切换时需要将数据尽可能的发送.\n\n关于第二点和第三点\n\n其实第二点和第三点的功能设计是相关的, 也就是说哪个条件先达到就先发送. 他们之间是 或者 的关系\n\n比如: 数据条数达到 20 条 或者 10s 内发送数据.\n\n那么, 在10s内如果超过了20条数据, 那应该直接发送.\n\n如果超过10s还没到20条数据, 也应该直接发送.\n\n关于第五点\n\n应该使用 navigator.sendBeacon 这个api去发送数据.\n\n这也是官方推荐的一种做法.\n\n(截止2024/7/19)当然这个方法会有一些限制, 比如:\n\n 1. 只能发送post请求\n 2. 发送数据格式有限制(常用的有字符串/FormData)\n 3. 无法自定义请求头.\n\n关于接口\n\n这块功能的接口需要与后端协商, 让后端配合. 这个就不多说了.\n\n\n数据分类#\n\n> 前端有多种数据类型可以上报.\n\n\n1. 日志#\n\n日志类型#\n\n\n\n上报内容#\n\n\n\n\n2. 性能数据#\n\n这里可以收集到前端的一些数据. 使用 window.performance 这个api可以获取到, 为了方便就直接贴代码了.\n\n\n\n\n3. 资源数据#\n\n这里是收集资源加载时间, 用于统计. 实际上也是使用 window.performance 这个api. 为了方便就直接贴代码了.\n\n\n\n\n展示#\n\n> 数据都有了, 怎么展示就看自己了. 这里贴一张我自己的简单效果. 没做太复杂~~\n> \n> 有兴趣的自行参考网上的效果.","routePath":"/doc/views/note/collect","lang":"","toc":[{"text":"请求","id":"请求","depth":2,"charIndex":117},{"text":"数据分类","id":"数据分类","depth":2,"charIndex":740},{"text":"1. 日志","id":"1-日志","depth":3,"charIndex":766},{"text":"日志类型","id":"日志类型","depth":4,"charIndex":774},{"text":"上报内容","id":"上报内容","depth":4,"charIndex":783},{"text":"2. 性能数据","id":"2-性能数据","depth":3,"charIndex":793},{"text":"3. 资源数据","id":"3-资源数据","depth":3,"charIndex":870},{"text":"展示","id":"展示","depth":2,"charIndex":950}],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"非覆盖式发布更新","content":"#\n\n\n背景#\n\n在传统前端项目发布更新的流程中, 一般是打包后直接覆盖掉线上的资源文件, 但这样子存在着一些问题.\n\n 1. 如果是整个文件夹直接覆盖, 那么将存在小部分的可能性, 就是用户停留在页面, 这时候更新了, 那么用户就可能出现文件找不到的情况.\n\n\n\n 2. 如果线上出现问题, 需要回滚git后才能重新发版, 这个过程有时并不是那么方便.\n\n\n非覆盖式发布#\n\n\n思路#\n\n> 如图所示, 思路其实很简单, 就是将打包后的资源放到oss服务器内, 每次更新都有一个对应的版本号, 不会相互覆盖.\n> \n> 也就是说, 所有的资源都会一直存在, 这就样解决了上面第一点说的问题.\n> \n> 至于第二点, 也非常方便, 因为所有的发布版本都有保存, 回滚上一个版本将轻而易举.\n\n\n模拟实现#\n\n提示\n\n为了更简单的说明问题, 这里不使用oss, 都使用 nodejs 来模拟服务器, 道理都是一样的.\n\n静态资源服务器(模拟OSS)#\n\n> 这里除了提供资源访问的功能, 还需要提供一个接口, 用来给别人上传资源.\n\n目录结构\n\n\n\n代码\n\n\n\n到这里, 一个带上传功能的静态资源服务器就可以了.\n\n公司内部服务器(模拟nginx)#\n\n目录结构\n\n\n\n代码\n\n\n\n到这里, 一个带上传功能的nginx服务器就可以了.\n\n前端项目(这里为 vite + vue3 为例)#\n\n这里需要修改打包时的配置,\n\n需要修改的是: 打包后的文件夹名称 / 打包后的静态资源访问路径.\n\n为了方便说明, 这里也没有集成 cicd , 打包后直接将资源发送到对应的服务器\n\n\n\n\n\n\n完整代码地址#\n\n> https://github.com/mmxCoder/non-overlay-publishing","routePath":"/doc/views/note/nonOverlayPublishing","lang":"","toc":[{"text":"背景","id":"背景","depth":2,"charIndex":3},{"text":"非覆盖式发布","id":"非覆盖式发布","depth":2,"charIndex":179},{"text":"思路","id":"思路","depth":3,"charIndex":189},{"text":"模拟实现","id":"模拟实现","depth":3,"charIndex":346},{"text":"静态资源服务器(模拟OSS)","id":"静态资源服务器模拟oss","depth":4,"charIndex":408},{"text":"公司内部服务器(模拟nginx)","id":"公司内部服务器模拟nginx","depth":4,"charIndex":506},{"text":"前端项目(这里为 vite + vue3 为例)","id":"前端项目这里为-vite--vue3-为例","depth":4,"charIndex":567},{"text":"完整代码地址","id":"完整代码地址","depth":3,"charIndex":691}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"浅试npm私有仓库","content":"#\n\n\n工具 Verdaccio#\n\n> 这个工具已经把大多数功能就做好了, 基本上是开箱即用.\n\n\n用法#\n\n安装 :\n\n\n\n运行 :\n\n\n\n看效果\n\n> 打开 http://localhost:4873/ (这是默认端口, 可自行配置)\n\n为项目设置源\n\n> 在项目更目录运行:\n\n\n\n发布包\n\n\n\n\n说明#\n\n总的来说, 如果没有复杂的需求, 只想要一个私有仓库管理自己的包, 那么这个库直接开箱即用.\n\n如果需要更多自定义配置, 请参考文档: https://verdaccio.org/zh-CN/","routePath":"/doc/views/note/npmPrivate","lang":"","toc":[{"text":"工具 Verdaccio","id":"工具-verdaccio","depth":2,"charIndex":3},{"text":"用法","id":"用法","depth":2,"charIndex":50},{"text":"说明","id":"说明","depth":2,"charIndex":152}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"纯前端实现发版通知","content":"#\n\n一个很常见的需求是前端发版后需要 通知还停留在页面的用户 及时去刷新页面.\n\n\n方案#\n\n> 下面介绍几个常见的方式\n\n\n方法一: 轮询后端接口获取版本信息#\n\n由后端去维护版本信息, 前端只需要轮询接口, 就可以实现\n\n提示\n\n这种方法需要后端提供一个获取接口, 不断轮询.\n\n\n方法二: websocket / sse 获取版本信息#\n\n与 方法一 一样, 同样由后端去维护版本信息, 前端只需要监听\n\n不同的是, 不需要前端去轮询.\n\n提示\n\n虽然减少了轮询, 但这实际上跟 方法一 一样, 需要后端去维护这个信息. 实际上这对后端来说\n\n其实是不需要的, 这个信息只是前端为了一个简单的通知.\n\n\n方法三: 纯前端实现#\n\n实际上版本信息应该是可以由 , 没必要放到后端去解决. 这里以 作为说明.\n\n 1. 首先在 文件下新增一个文件保存版本信息, 如: version.json\n\n\n\n 2. 自动更新版本信息, 这里在vite打包时自动更新.\n\n\n\n 3. 前端轮询上面的这个json文件\n\n> 这里就直接请求就可以了, 然后判断版本字段是否变大了, 是的话就是发布版本了.\n\n\n注意事项 / 说明 (针对方法三)#\n\n 1. 上面只展示了最基本的思路, 并且在实际项目中是可行的. 但如果应用到项目中, 需要自行完善和扩展该功能的细节.\n 2. 上面说的 文件里面放的是一个 对象 , 不是一个数组. 因为我这边的项目使用了 cicd , 没办法使用数组保存多个发版记录.\n\n原因\n\n在打包服务器内每次都会拉取新代码去打包,\n\n如果想解决的话, 可以先去请求线上的版本文件, 拿到最新的数据, 但我这边没这个需求就没写了.\n\n这个文件在打包时被更新. 但是这个更新是在打包服务器上的, 并不是 git 仓库内的, 这就是说, 当下一次更新打包时, 还是\n\n第一次的那个记录, 第二次打包的记录没有被保存.\n\n 3. 关于更新文件, 其实可以不用在 vite.config.ts 文件做, 也可以在 package.json 中做.\n\n\n\n\n思路补充#\n\nTIP\n\n在 掘金 看到这个问题的讨论后又得到了几个新的思路, 在下面说明\n\n 1. 后端将版本号放到每个请求的 响应头 中, 前端每次请求后判断这个版本号是否更新.\n 2. 监听错误信息 , 当直接使用覆盖式更新时, 原先的js不存在, 会产生报错. ( 点击查看具体原因 ). 所以通过监听脚本错误去判断是否发版","routePath":"/doc/views/note/publish","lang":"","toc":[{"text":"方案","id":"方案","depth":2,"charIndex":42},{"text":"方法一: 轮询后端接口获取版本信息","id":"方法一-轮询后端接口获取版本信息","depth":3,"charIndex":63},{"text":"方法二: websocket / sse 获取版本信息","id":"方法二-websocket--sse-获取版本信息","depth":3,"charIndex":143},{"text":"方法三: 纯前端实现","id":"方法三-纯前端实现","depth":3,"charIndex":305},{"text":"注意事项 / 说明 (针对方法三)","id":"注意事项--说明-针对方法三","depth":2,"charIndex":499},{"text":"思路补充","id":"思路补充","depth":2,"charIndex":880}],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"任务并发控制","content":"#\n\n> 如果你是一个前端开发, 你应该知道浏览器对同域名的请求是有并发限制的.\n> \n> 比如chrome中, 这个限制为 6个 , 也就是说, 如果你初始化的资源请求超过 6个 时, 多余的将进行等待,\n> \n> 等到有空缺时才进行请求, 也就是同一时间 最多只能是6个 .\n\n提示\n\n具体原因可以点击:\n\n\n自己实现任务池限制#\n\n> 在前端代码上, 我们要实现的就不仅仅是请求层面的控制, 而是针对所有情况, 应该是说 Task(任务) , 任何一个函数都可以称为一个任务.\n\n\n设计基本架构#\n\n\n\n开始实现 addTask 函数#\n\n> 这个函数很简单, 就执行把任务函数推进队列就可以了.\n\n\n\n开始实现 execTask 函数#\n\n> 这个函数就麻烦一点, 这个控制逻辑都在这里执行.\n\n","routePath":"/doc/views/note/requestControl","lang":"","toc":[{"text":"自己实现任务池限制","id":"自己实现任务池限制","depth":2,"charIndex":156},{"text":"设计基本架构","id":"设计基本架构","depth":3,"charIndex":243},{"text":"开始实现 addTask 函数","id":"开始实现-addtask-函数","depth":4,"charIndex":254},{"text":"开始实现 execTask 函数","id":"开始实现-exectask-函数","depth":4,"charIndex":304}],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"服务端通知","content":"#\n\n提示\n\n这里只做服务端主动通知的方案, 就不说明 的方案了, 因为这个方案已经过时了.\n\n\nServer-Sent Events (SSE)#\n\n> 这是一种在客户端和服务器之间实现单向事件流的机制，允许服务器主动向客户端发送事件数据。在 SSE 中，可以使用自定义事件（Custom\n> Events）来发送具有特定类型的事件数据。\n\n\n实现#\n\n后端(nodejs)#\n\n\n\n说明#\n\n 1. 发送给客户端的形式都是以 [field]: value 的形式编写的. 这里的 field 取值如下:\n\n\n\n请注意: 在一个事件内, 每次指定数据后都需要加上 \\n 结尾. 最后一个使用 \\n\\n 结尾.\n\n 2. 关于上面的 id 和 retry 字段, 如果你想看到实际效果, 可以这样.\n\n\n\n前端#\n\n\n\n说明:#\n\n 1. 当发生错误断开链接时, sse会自动进行重连, 如果你想阻止重连, 可以这么做:\n\n\n\n\n案例地址#\n\n> https://github.com/mmxCoder/demo/tree/main/sse\n\n\nwebsocket#\n\n> 这是一种双全工的协议, 与SSE不同的是, 客户端和服务端可以相互通信.\n\n说明\n\n这里借助 ws 这个库来实现.\n\n\n实现#\n\n后端(nodejs)#\n\n\n\n启动一个ws服务非常简单, 实际上就是两个动作(实际上前端也是如此), 监听 / 发送\n\n前端#\n\n\n\n效果#","routePath":"/doc/views/note/serverNotify","lang":"","toc":[{"text":"Server-Sent Events (SSE)","id":"server-sent-events-sse","depth":2,"charIndex":48},{"text":"实现","id":"实现","depth":3,"charIndex":172},{"text":"后端(nodejs)","id":"后端nodejs","depth":4,"charIndex":177},{"text":"前端","id":"前端","depth":4,"charIndex":352},{"text":"案例地址","id":"案例地址","depth":3,"charIndex":414},{"text":"websocket","id":"websocket","depth":2,"charIndex":472},{"text":"实现","id":"实现-1","depth":3,"charIndex":546},{"text":"后端(nodejs)","id":"后端nodejs-1","depth":4,"charIndex":551},{"text":"前端","id":"前端-1","depth":4,"charIndex":611},{"text":"效果","id":"效果","depth":4,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":15,"title":"记录一次调试vxeTable源码","content":"#\n\n提示\n\nvxe-table 是vue3的一个表格插件.\n\n\n经过#\n\n事实是这样的, 突然有一天同事说这个表格怎么这么卡呢.试了一下也确实是, 滑动的时候莫名的卡顿\n\n并且才100条数据就已经能肉眼感觉卡顿了.\n\n\n定位#\n\n\n场景复现#\n\n\n\n\n打开chorme性能面板分析#\n\n结果\n\n可以看到一个很熟悉的函数, patch , 这个是vue源码里面的diff算法函数.\n\ndiff算法 其实是在对比 虚拟DOM 和 挂载DOM 的一个过程. 它是一个 递归 的过程.\n\n耗时发生在它身上说明 dom节点太多了.\n\n但不科学的是, 才一百列, 十条数据, 并且已经开启了虚拟滚动. 理论上不应该出现卡顿.\n\n但事实却很奇怪...继续排查.\n\n\n控制台打印节点个数#\n\n结果\n\n从输出看上是 一千多个单元格节点, 是不是以为是对的 100 * 10 都一千个了.但是实际上是不对的, 因为开启了虚拟滚动,\n\n看不见的节点很多是没经过渲染的.问题就在这了.\n\n接着, 鼠标移上去发现 很多节点是重复 的.\n\n\n验证是否重复渲染节点#\n\n\n\n继续控制台打印节点个数.#\n\n结果\n\n问题得到了验证, 10条数据但是节点被渲染了20次, 多了一倍的节点.\n\n最终的结果是发现, 当存在 fixed 固定列时, 整个表格会被多渲染 1-2 倍的节点\n\n\n验证是否为插件问题#\n\n方案\n\n到官网的demo上用上面的方案定位了一下, 发现 并没有 出现相同的情况\n\n这种情况就有点棘手了, 因为很难定位到具体是哪行代码导致了表格插件出现了重复渲染.\n\n\n解决#\n\n> 走投无路, 最终只能是去debug源码.\n\n问题\n\n官方又不存在这个问题, 应该如何在源码上复现呢?\n\n这时候就要使用另外的一个东西了. 那就是 npm link\n\n这个命令呢, 是用来调试本地库的, 相当于一个 软连接 ,\n\n比如: 当你在代码里面写上 `` 时,\n\n实际上是引入了 npm install 装的包. 但 npm install 是需要你发布到 npmjs.com 上才可以的.\n\n现在如果是本地开发过程中, 又想测试的话怎么办呢, 就可以使用 npm link , 将这个包链接到全局. 并在项目中 link 进来.\n\n具体的信息请自行查询, 这里不做过多解释.\n\n> 终于在一通打印调试之后, 在源码里面发现了问题.\n\n结果\n\n当配置了扩展列并且存在固定列时, 固定列会进行 全量渲染, 就是将整个表格又渲染一遍.\n\n如果左右都存在固定列, 那么将多渲染 2倍 的节点. 这就是卡顿的最终原因.\n\n\n修改代码#\n\n> 原来, 调用方并没有配置扩展行, 但是在二次封装时写上了,\n\n\n\n> 也就是这一列, 导致了表格开启了全量渲染, 因为表格内部只判断了是否存在该列, 并没有判断该列是否隐藏. 所以, 问题的根源找到了.\n\n> 最后问题就解决了. 根据配置项动态判断是否把该列加到列配置上去, 而不是加上后根据配置判断显隐.\n\n\n结束#","routePath":"/doc/views/note/vxeTable","lang":"","toc":[{"text":"经过","id":"经过","depth":2,"charIndex":32},{"text":"定位","id":"定位","depth":2,"charIndex":110},{"text":"场景复现","id":"场景复现","depth":3,"charIndex":116},{"text":"打开chorme性能面板分析","id":"打开chorme性能面板分析","depth":3,"charIndex":126},{"text":"控制台打印节点个数","id":"控制台打印节点个数","depth":3,"charIndex":326},{"text":"验证是否重复渲染节点","id":"验证是否重复渲染节点","depth":3,"charIndex":457},{"text":"继续控制台打印节点个数.","id":"继续控制台打印节点个数","depth":4,"charIndex":472},{"text":"验证是否为插件问题","id":"验证是否为插件问题","depth":2,"charIndex":575},{"text":"解决","id":"解决","depth":2,"charIndex":673},{"text":"修改代码","id":"修改代码","depth":2,"charIndex":1091},{"text":"结束","id":"结束","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"测试一下..","content":"#","routePath":"/doc/views/reflection/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"测试一下..","content":"#","routePath":"/doc/views/study/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"如何等待分散在不同的模块内部的多个异步结束?","content":"#\n\n\n场景#\n\n> 在表格中, 表格的数据取决于其他的几个状态, 并且这几个状态都是异步获取的 这几个状态都分散在不同的几个模块内部,\n> 那么该如何组织代码才可以比较友好的实现该需求.\n\n\n示例#\n\n> 上面是一个最简单的示例复现.\n> \n> 想象一下, 顶部的三个状态都是异步请求回来的, 并且有可能这三个是分布在 不同 的组件内部,\n> \n> 表格需要等到这三个 异步结束 后再去请求数据.\n\n思考\n\n针对以上的场景, 应该如何组织代码才可以比较友好呢?\n\n\n目前的解决方案#\n\n问题\n\n这个方案看似解决了问题, 即多个模块可以单独调用加载方法, 不需要管其他状态是否结束. 最终的请求由表格内部去判断什么时候执行.\n\n但是, 这引发了其他的问题.\n\n 0. 调用方需要手动指定初始化时总共有多少个异步状态, 也就说初始化时需要调用多少次加载方法, 因为表格并不能感知这个条件, 所以无法判断啥时候需要发起请求.\n 1. 如果存在多个状态, 但其中一个状态失败了, 这种情况将有点麻烦. 可能还需要手动指定是否需要发起请求.","routePath":"/doc/views/think/asyncAwait","lang":"","toc":[{"text":"场景","id":"场景","depth":2,"charIndex":3},{"text":"示例","id":"示例","depth":2,"charIndex":96},{"text":"目前的解决方案","id":"目前的解决方案","depth":2,"charIndex":233}],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"思考: 多个hook之间的耦合度应该如何解耦","content":"#\n\n> 现在 函数式编程 是前端开发中的主流思想, hook 也作为主流的思想被越来越多人所实践并推行.\n> \n> 但在实践开发中, 总会遇到一种情况, 就是 多个hook 之间的相互依赖.\n\n\n\n按上面的例子, useHookB 依赖了 useHookA 的一个状态.这还是一个最简单的一种情况, 实际情况中可能更加复杂.\n\n可能存在多个 hook 相互依赖等情况.\n\n思考\n\n应该如何去解耦这中间的耦合?\n\n有兴趣可以看看下面这个解决方案: vue3 + IOC\n\nhttps://zova.js.org/zh/guide/start/why.html","routePath":"/doc/views/think/hook","lang":"","toc":[],"domain":"","frontmatter":{},"version":""}]